// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.1
// LVGL version: 8.3.11
// Project name: SmartWatch

#include "ui_Settings.h"
#include "DisplayManager.h"
#include "SettingsManager.h"
//#include "mc_circular_keyboard.h"

lv_obj_t * arc_segments[NUM_SEGMENTS];
const char * segment_labels[NUM_SEGMENTS] = {"Wi-Fi", "General", "Home", "Bluetooth", "Weather", "Sound"};



lv_obj_t * wifi_list;
lv_obj_t * content_area;
lv_obj_t * ui_SettingsRadialMenu;
lv_obj_t * content_label;
static lv_obj_t * password_kb;
int segment_index;
bool doScreenBrightnessUpdate;

static const char *keyboard_context = nullptr;




void create_content_area(void) {
    content_area = lv_obj_create(ui_Settings);
    lv_obj_set_size(content_area, 240, 240); // Adjust size to avoid overlapping with symbols
    lv_obj_center(content_area);
    lv_obj_add_flag(content_area, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(content_area, lv_color_white(), 0);
    lv_obj_set_style_radius(content_area, LV_RADIUS_CIRCLE, 0);
    lv_obj_set_scrollbar_mode(content_area, LV_SCROLLBAR_MODE_AUTO);

   // lv_obj_set_style_pad_all(content_area, 10, 0); // Add padding if needed

    
}

void handle_keyboard_close(bool is_ok_pressed) {
    if (is_ok_pressed) {
        printf("OK pressed. Context: %s\n", keyboard_context);

        if (strcmp(keyboard_context, "sound_settings") == 0) {
            // Handle OK for sound settings
            printf("Handle OK for sound settings.\n");
        } else if (strcmp(keyboard_context, "wifi_password") == 0) {
            // Handle OK for WiFi password
            printf("Save WiFi password.\n");
        } else if (strcmp(keyboard_context, "bluetooth_name") == 0) {
            // Handle OK for Bluetooth device name
            printf("Save Bluetooth device name.\n");
        }
        // Add more contexts as needed
    } else {
        printf("Cancel pressed. Restoring radial menu and buttons.\n");
    }

    // Always restore the radial menu on close
    show_radial_menu_and_buttons();
}


void show_wifi_settings(void) {
    lv_obj_clean(content_area); // Clear previous content

        // Use a flex layout to arrange labels and sliders in a column
    lv_obj_set_flex_flow(content_area, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(content_area, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER); 

    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "Wi-Fi Settings");
    lv_obj_align(content_label, LV_ALIGN_TOP_MID, 0, 10);

    // Create Wi-Fi switch to enable/disable Wi-Fi
    lv_obj_t * wifi_switch = lv_switch_create(content_area);
    lv_obj_align(wifi_switch, LV_ALIGN_TOP_LEFT, 20, 40);
    lv_obj_add_event_cb(wifi_switch, wifi_switch_event_cb, LV_EVENT_VALUE_CHANGED, NULL);

/*     // Label for the Wi-Fi switch
    lv_obj_t * switch_label = lv_label_create(content_area);
    lv_label_set_text(switch_label, "Wi-Fi On/Off");
    lv_obj_align_to(switch_label, wifi_switch, LV_ALIGN_TOP_LEFT, 0, 40); */

    // Create list for Wi-Fi networks (both saved and scanned)
    //lv_obj_t * wifi_list = lv_list_create(content_area);
    wifi_list = lv_list_create(content_area);
    lv_obj_set_size(wifi_list, lv_pct(90), lv_pct(40));
    lv_obj_align(wifi_list, LV_ALIGN_CENTER, 0, 0);
    lv_obj_set_style_pad_all(wifi_list, 5, 0);
    lv_list_add_text(wifi_list, "Wi-Fi Networks");
    if (wifi_list == nullptr) {
    Serial.println("Error in show_wifi_settings: Wi-Fi list is not initialized.");
    return;
}

    // Add event to populate the list of networks when Wi-Fi is enabled
    lv_obj_add_event_cb(wifi_switch, wifi_switch_event_cb, LV_EVENT_VALUE_CHANGED, wifi_list);

   // scan_and_display_wifi_networks();
}


void show_sleep_settings(void) {
    //lv_obj_clean(content_area); // Clear previous content

    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "Sleep Timer");
    lv_obj_align(content_label, LV_ALIGN_TOP_MID, 0, 20);

    // Create sleep timer slider
    lv_obj_t * slider = lv_slider_create(content_area);
    lv_obj_set_width(slider, lv_pct(80));
    lv_obj_align(slider, LV_ALIGN_CENTER, 0, 30);
    lv_slider_set_range(slider, 5, 60);
    lv_slider_set_value(slider, currentSettings.sleep_duration, LV_ANIM_OFF);
    lv_obj_add_event_cb(slider, sleep_timer_slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);
}

void create_radial_menu(void)
{
// Create the arc
    ui_SettingsRadialMenu = lv_arc_create(ui_Settings);
    lv_obj_set_size(ui_SettingsRadialMenu, 400, 400);
    lv_obj_center(ui_SettingsRadialMenu);
    lv_arc_set_bg_angles(ui_SettingsRadialMenu, 0, 360); // Full circle
    lv_arc_set_range(ui_SettingsRadialMenu, 0, 600);
   // lv_arc_set_value(ui_SettingsRadialMenu, 0);
    lv_obj_set_style_arc_width(ui_SettingsRadialMenu, 50, LV_PART_MAIN); // Adjust thickness
    lv_obj_set_style_arc_width(ui_SettingsRadialMenu, 50, LV_PART_INDICATOR); // Adjust thickness
    lv_obj_set_style_arc_color(ui_SettingsRadialMenu, lv_color_hex(0x2c2836), LV_PART_MAIN);
    
    //lv_obj_remove_style(ui_SettingsRadialMenu, NULL, LV_PART_KNOB); // Remove knob
    // Make the knob invisible but functional
    lv_obj_set_style_bg_opa(ui_SettingsRadialMenu, LV_OPA_TRANSP, LV_PART_KNOB);

    lv_obj_set_style_arc_rounded(ui_SettingsRadialMenu, false, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_arc_set_rotation(ui_SettingsRadialMenu, -90);


    lv_obj_set_align(ui_SettingsRadialMenu, LV_ALIGN_CENTER);

    lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_SCROLLABLE);

    // Initialize the indicator to the first segment
    lv_arc_set_start_angle(ui_SettingsRadialMenu, 0);
    lv_arc_set_end_angle(ui_SettingsRadialMenu, 360 / NUM_SEGMENTS);

}


void ui_Settings_screen_init(void)
{
    Serial.println("ui_Settings_screen_init was called");
    ui_Settings = lv_obj_create(NULL);
    lv_obj_clear_flag(ui_Settings, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_style_bg_color(ui_Settings, lv_color_hex(0x100820), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_Settings, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_size(ui_Settings, 412, 412);
    create_radial_menu();
    create_content_area();
     add_segment_buttons(); // Use this if you're creating buttons
}

void add_segment_buttons(void) {
    int angle_per_segment = 360 / NUM_SEGMENTS;
    const char * segment_symbols[NUM_SEGMENTS] = {LV_SYMBOL_WIFI, LV_SYMBOL_SETTINGS, LV_SYMBOL_HOME, LV_SYMBOL_BLUETOOTH, LV_SYMBOL_REFRESH, LV_SYMBOL_AUDIO};

    for (int i = 0; i < NUM_SEGMENTS; i++) {
        int mid_angle = i * angle_per_segment + angle_per_segment / 2;
        int radius = 150; // Adjust radius to position the button within the segment
        mid_angle -= 90;
        if (mid_angle <= 0) {
            mid_angle += 360;
        }

        // Convert angle to radians
        float rad = mid_angle * 3.14159265 / 180.0;

        int x = (int)(radius * cos(rad));
        int y = (int)(radius * sin(rad));

        // Create a button for the segment
        lv_obj_t * btn = lv_btn_create(ui_Settings);
        if (!btn) {
            printf("Error: Failed to create segment button %d\n", i);
            continue;
        }

        arc_segments[i] = btn; // Store the button in the arc_segments array

        lv_obj_set_style_radius(btn, LV_RADIUS_CIRCLE, 0);
        lv_obj_set_size(btn, 40, 40); // Adjust size as needed
        lv_obj_align(btn, LV_ALIGN_CENTER, x, y);
        lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, 0); // Make button background transparent
        lv_obj_set_style_border_opa(btn, LV_OPA_TRANSP, LV_PART_MAIN);
        lv_obj_set_style_shadow_width(btn, 0, 0);

        // Create a label for the symbol inside the button
        lv_obj_t * symbol_label = lv_label_create(btn);
        lv_label_set_text(symbol_label, segment_symbols[i]);
        lv_obj_align(symbol_label, LV_ALIGN_CENTER, 0, 0);
        lv_obj_set_style_text_font(symbol_label, &lv_font_montserrat_24, 0); // Adjust font size as needed
        lv_obj_set_style_text_color(symbol_label, lv_color_white(), 0); // Set text color
        lv_obj_set_style_text_color(symbol_label, lv_color_hex(0x79CBFC), LV_STATE_PRESSED);

        // Assign the segment index as user data
        lv_obj_set_user_data(btn, (void *)(intptr_t)i);
        //lv_obj_set_style_pad_all(btn, 30, LV_STATE_PRESSED);
        lv_obj_set_ext_click_area(btn, 10);
        // Add event callback to the button
        lv_obj_add_event_cb(btn, segment_btn_event_cb, LV_EVENT_CLICKED, NULL);
    }
}


void segment_btn_event_cb(lv_event_t * e)
{
    lv_obj_t * btn = (lv_obj_t *)lv_event_get_target(e);
    int segment_index = (int)(intptr_t)lv_obj_get_user_data(btn);

    if (!ui_SettingsRadialMenu) {
        return;  // Ensure the radial menu is valid
    }


    // Update the arc's indicator to highlight the selected segment
    int total_angle = 360;
    int section_angle = total_angle / NUM_SEGMENTS;
    
    int indicator_start_angle = segment_index * section_angle;
    int indicator_end_angle = (segment_index + 1) * section_angle;

    lv_arc_set_start_angle(ui_SettingsRadialMenu, indicator_start_angle);
    lv_arc_set_end_angle(ui_SettingsRadialMenu, indicator_end_angle);

    // Perform the action based on the segment index
    switch(segment_index) {
        case 0: // Wi-Fi
            show_wifi_settings();
            break;
        case 1: // General
            show_general_settings();
            break;
        case 2: // Home
            // Time to save the settings.
               saveSettingsDataToFile("/settings.json", currentSettings);
            _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_FADE_ON, 100, 0, ui_MainScreen_screen_init);
            break;
        case 3: // Bluetooth
            show_bluetooth_settings();
            break;
        case 4: // Weather
            show_weather();
            break;
        case 5: // Sound
            show_sound_settings();
            break;
        default:
            break;
    }
}

void arc_event_cb(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    if(event_code == LV_EVENT_PRESSING) {
        settingsMenu_valuechange(e);
    }
    if(event_code == LV_EVENT_RELEASED) {
        settingsMenu_select(e);
    }
}

void settingsMenu_valuechange(lv_event_t * e)
{
    lv_obj_t * arc = (lv_obj_t *)lv_event_get_target(e);

// Get the touch point coordinates
    lv_indev_t * indev = lv_indev_get_act();
    lv_point_t touch_point;
    lv_indev_get_point(indev, &touch_point);

    // Get the arc's center coordinates
    lv_area_t arc_coords;
    lv_obj_get_coords(arc, &arc_coords);
    lv_coord_t arc_center_x = arc_coords.x1 + lv_area_get_width(&arc_coords) / 2;
    lv_coord_t arc_center_y = arc_coords.y1 + lv_area_get_height(&arc_coords) / 2;

    // Calculate the difference in x and y from the center
    int dx = touch_point.x - arc_center_x;
    int dy = arc_center_y - touch_point.y ;

    // Calculate the angle in degrees (0 to 360)
    float angle = atan2f(dx, dy) * (180.0f / 3.14159265f);
    if (angle < 0) {
        angle += 360.0f;
    }



    // Adjust the angle based on the arc's rotation
   // angle -= 90.0f; // Since we rotated the arc by -90 degrees
    if (angle < 0) {
        angle += 360.0f;
    }

    // Calculate the segment index

    float segment_angle = 360.0f / NUM_SEGMENTS;
     segment_index = (int)(angle / segment_angle);
    if(segment_index >= NUM_SEGMENTS) segment_index = 0;

    // Update the arc's indicator to highlight the selected segment
    int indicator_start_angle = segment_index * segment_angle;
    int indicator_end_angle = (segment_index + 1) * segment_angle;

    lv_arc_set_start_angle(arc, indicator_start_angle);
    lv_arc_set_end_angle(arc, indicator_end_angle);

    // Debug output
    Serial.printf("dx: %d, dy: %d, angle: %.2f, segment_index: %d\n", dx, dy, angle, segment_index);

}

void settingsMenu_select(lv_event_t * e)
{
    lv_obj_t * arc = (lv_obj_t *)lv_event_get_target(e);

    // Debug output
    Serial.printf("Segment Selected: %d\n", segment_index);

    // Perform the action based on the segment index
    switch(segment_index) {
        case 0: // Wi-Fi
            show_wifi_settings();
            break;
        case 1: // General
            show_general_settings();
            break;
        case 2: // Home
         //lv_arc_set_start_angle(ui_MainArcMenu, 120);
         //lv_arc_set_end_angle(ui_MainArcMenu, 180);
         //lv_label_set_text(ui_screenselectlabel, "Main");
         lv_arc_set_value(ui_MainArcMenu, 0);
            _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_FADE_ON, 10, 0, ui_MainScreen_screen_init);
            break;
        case 3: // Bluetooth
            show_bluetooth_settings();
            break;
        case 4: // Weather
            show_weather();
            break;
        case 5: // Sound
            show_sound_settings();
            break;
        default:
            break;
    }
}
 
void hide_radial_menu_and_buttons(void) {
    if (ui_SettingsRadialMenu) {
        lv_obj_add_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN); // Hide the radial menu
    }

    for (int i = 0; i < NUM_SEGMENTS; i++) {
        if (arc_segments[i]) {
            lv_obj_add_flag(arc_segments[i], LV_OBJ_FLAG_HIDDEN); // Hide each segment button
            printf("Hid arc_segment[%d] \n", i);
        } else {
            printf("Warning: arc_segments[%d] is NULL\n", i);
        }
    }
}


void show_radial_menu_and_buttons(void) {
    if (ui_SettingsRadialMenu) {
        if (!lv_obj_is_valid(ui_SettingsRadialMenu)) {
            printf("Warning: ui_SettingsRadialMenu is invalid.\n");
            return;
        }
        lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN); // Show the radial menu
    } else {
        printf("Warning: ui_SettingsRadialMenu is NULL.\n");
    }

    for (int i = 0; i < NUM_SEGMENTS; i++) {
        if (arc_segments[i]) {
            if (!lv_obj_is_valid(arc_segments[i])) {
                printf("Warning: arc_segments[%d] is invalid.\n", i);
                continue;
            }
            lv_obj_clear_flag(arc_segments[i], LV_OBJ_FLAG_HIDDEN); // Show each segment button
            printf("Shown arc_segments[%d].\n", i);
        } else {
            printf("Warning: arc_segments[%d] is NULL.\n", i);
        }
    }
}



// **Wi-Fi Switch Event Callback** 
void wifi_switch_event_cb(lv_event_t *e) {
    lv_obj_t *sw = (lv_obj_t *)lv_event_get_target(e);

    if (lv_obj_has_state(sw, LV_STATE_CHECKED)) {
        wifi_enable();
        delay(200);
        scan_and_display_wifi_networks();
    } else {
        wifi_disable();
        if (wifi_list == nullptr) {
        Serial.println("Error in wifi_switch event. Can't remove wifi list, list is not initialized.");
        }
        else
        {
            lv_obj_clean(wifi_list); // Clear the list
        }
    }
}


void brightness_slider_event_cb(lv_event_t * e) {
    lv_obj_t * slider = (lv_obj_t *)lv_event_get_target(e);
    
 
        uint8_t value = lv_slider_get_value(slider);
        
        // Ensure value is not below 10
        if (value < 10) {
            value = 10;
            lv_slider_set_value(slider, value, LV_ANIM_ON);
        }
        currentSettings.brightness_level = value;
        
       // Serial.printf("Slider value changed: %d\n", value);
      // Serial.printf("Settings Brightness Level is set to: %d\n", currentSettings.brightness_level);
      //  powerManager.setBacklightBrightness(value);
    

}

void brightness_slider_released_event_cb(lv_event_t *e) {
    lv_obj_t *slider = (lv_obj_t *)lv_event_get_target(e);
    uint8_t value = lv_slider_get_value(slider);
    currentSettings.brightness_level = value;
    DisplayManager::instance().setBrightness(value);

    Serial.printf("Slider released, final value: %d\n", value);
   

    // Make sure brightness is properly updated
  //  powerManager.setBacklightBrightness(value);
}



void sleep_timer_slider_event_cb(lv_event_t * e) {
    lv_obj_t * slider = (lv_obj_t *)lv_event_get_target(e);
    uint8_t value = lv_slider_get_value(slider);
    // Adjust the sleep timer accordingly
    // Implement set_sleep_timer(value);
}

void show_general_settings(void) {
    lv_obj_clean(content_area); // Clear previous content

    // Use a flex layout to arrange labels and sliders in a column
    lv_obj_set_flex_flow(content_area, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(content_area, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER); 
    
    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "General Settings");
    lv_obj_set_style_text_font(content_label, &lv_font_montserrat_12, 0);

    // Brightness Label
    lv_obj_t * brightness_label = lv_label_create(content_area);
    lv_label_set_text(brightness_label, "Display");

    // Brightness Slider
    lv_obj_t * brightness_slider = lv_slider_create(content_area);
    lv_obj_set_width(brightness_slider, lv_pct(80));
    lv_slider_set_range(brightness_slider, 10, 255);
    lv_obj_add_flag(brightness_slider, LV_OBJ_FLAG_CLICKABLE);
    lv_slider_set_value(brightness_slider, currentSettings.brightness_level, LV_ANIM_ON);
    lv_obj_set_style_anim_duration(brightness_slider, 2000, 0);
    lv_obj_add_event_cb(brightness_slider, brightness_slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);
    lv_obj_add_event_cb(brightness_slider, brightness_slider_released_event_cb, LV_EVENT_RELEASED, NULL);

    // Sleep Timer Label
    lv_obj_t * sleep_timer_label = lv_label_create(content_area);
    lv_label_set_text(sleep_timer_label, "Sleep Timer");

    // Sleep Timer Slider
    lv_obj_t * sleep_timer_slider = lv_slider_create(content_area);
    lv_obj_set_width(sleep_timer_slider, lv_pct(80));
    lv_slider_set_range(sleep_timer_slider, 5, 60);
    lv_slider_set_value(sleep_timer_slider, currentSettings.sleep_duration, LV_ANIM_OFF);
    lv_obj_add_event_cb(sleep_timer_slider, sleep_timer_slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL);

}

// Event callback for Bluetooth switch
void bluetooth_switch_event_cb(lv_event_t * e) {
    lv_obj_t * switch_obj = (lv_obj_t *) lv_event_get_target(e);
    bool bt_on = lv_obj_has_state(switch_obj, LV_STATE_CHECKED);
    
    if(bt_on) {
       // enable_bluetooth();  // Function to enable Bluetooth in your code
        //populate_device_list(); // Function to update device list
    } else {
        //disable_bluetooth(); // Function to disable Bluetooth in your code
        //lv_list_clean(bt_device_list); // Clear the device list
    }
}

// Callback functions for connect, disconnect, pair actions
void connect_btn_event_cb(lv_event_t * e) {
    const char * device_name = (const char *)lv_event_get_user_data(e);
    Serial.printf("Connecting to: %s\n", device_name);
    //connect_bluetooth_device(device_name);
}

void disconnect_btn_event_cb(lv_event_t * e) {
    const char * device_name = (const char *)lv_event_get_user_data(e);
    Serial.printf("Disconnecting from: %s\n", device_name);
    //disconnect_bluetooth_device(device_name);
}

void pair_btn_event_cb(lv_event_t * e) {
    const char * device_name = (const char *)lv_event_get_user_data(e);
    Serial.printf("Pairing with: %s\n", device_name);
    //pair_bluetooth_device(device_name);
}


// Event callback for selecting a Bluetooth device
void device_select_event_cb(lv_event_t * e) {
    lv_obj_t * btn = (lv_obj_t*)lv_event_get_target(e);
    const char * device_name = lv_list_get_button_text(bt_device_list, btn);
    Serial.printf("Selected device: %s\n", device_name);

    // Show the action container with connect/pair/disconnect buttons
    lv_obj_clear_flag(action_container, LV_OBJ_FLAG_HIDDEN);

    // Clean any previous buttons from action_container
    lv_obj_clean(action_container);

    // Add buttons for connect, disconnect, pair
    lv_obj_t * connect_btn = lv_btn_create(action_container);
    lv_obj_align(connect_btn, LV_ALIGN_LEFT_MID, 20, 0);
    lv_obj_t * connect_label = lv_label_create(connect_btn);
    lv_label_set_text(connect_label, "Connect");
    lv_obj_add_event_cb(connect_btn, connect_btn_event_cb, LV_EVENT_CLICKED, (void*)device_name);

    lv_obj_t * disconnect_btn = lv_btn_create(action_container);
    lv_obj_align(disconnect_btn, LV_ALIGN_CENTER, 0, 0);
    lv_obj_t * disconnect_label = lv_label_create(disconnect_btn);
    lv_label_set_text(disconnect_label, "Disconnect");
    lv_obj_add_event_cb(disconnect_btn, disconnect_btn_event_cb, LV_EVENT_CLICKED, (void*)device_name);

    lv_obj_t * pair_btn = lv_btn_create(action_container);
    lv_obj_align(pair_btn, LV_ALIGN_RIGHT_MID, -20, 0);
    lv_obj_t * pair_label = lv_label_create(pair_btn);
    lv_label_set_text(pair_label, "Pair");
    lv_obj_add_event_cb(pair_btn, pair_btn_event_cb, LV_EVENT_CLICKED, (void*)device_name);
}


void show_bluetooth_settings(void) {
    
    lv_obj_clean(content_area); // Clear previous content

    // Label
    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "Bluetooth Settings");
    lv_obj_align(content_label, LV_ALIGN_TOP_MID, 0, 10);

    // Create Bluetooth switch
    lv_obj_t * bt_switch = lv_switch_create(content_area);
    lv_obj_align(bt_switch, LV_ALIGN_TOP_LEFT, 20, 40);
    lv_obj_add_event_cb(bt_switch, bluetooth_switch_event_cb, LV_EVENT_VALUE_CHANGED, NULL);

    // Label for the switch
    lv_obj_t * switch_label = lv_label_create(content_area);
    lv_label_set_text(switch_label, "Bluetooth On/Off");
    lv_obj_align_to(switch_label, bt_switch, LV_ALIGN_OUT_RIGHT_MID, 10, 0);

    // Create list for available devices
    bt_device_list = lv_list_create(content_area);
    lv_obj_set_size(bt_device_list, lv_pct(90), lv_pct(40));
    lv_obj_align(bt_device_list, LV_ALIGN_CENTER, 0, 0);
    lv_obj_set_style_pad_all(bt_device_list, 5, 0);

    // Add sample devices (this should be updated dynamically based on available devices)
    lv_obj_t * list_btn = lv_list_add_btn(bt_device_list, LV_SYMBOL_BLUETOOTH, "Device 1");
    lv_obj_add_event_cb(list_btn, device_select_event_cb, LV_EVENT_CLICKED, bt_device_list);

    list_btn = lv_list_add_btn(bt_device_list, LV_SYMBOL_BLUETOOTH, "Device 2");
    lv_obj_add_event_cb(list_btn, device_select_event_cb, LV_EVENT_CLICKED, bt_device_list);

    // Container for actions (connect, disconnect, pair)
    action_container = lv_obj_create(content_area);
    lv_obj_set_size(action_container, lv_pct(90), 60);
    lv_obj_align(action_container, LV_ALIGN_BOTTOM_MID, 0, -10);
    lv_obj_set_style_bg_color(action_container, lv_color_hex(0xFFFFFF), 0);
    lv_obj_set_style_border_width(action_container, 1, 0);
    lv_obj_set_style_radius(action_container, 5, 0);
    lv_obj_add_flag(action_container, LV_OBJ_FLAG_HIDDEN);
}


void show_weather(void) {
   lv_obj_clean(content_area); // Clear previous content

    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "Weather");
    lv_obj_align(content_label, LV_ALIGN_TOP_MID, 0, 10);

    // Display weather information here
}

void show_sound_settings(void) {
    lv_obj_clean(content_area); // Clear previous content

    content_label = lv_label_create(content_area);
    lv_label_set_text(content_label, "Sound Settings");
    lv_obj_align(content_label, LV_ALIGN_TOP_MID, 0, 10);

    // Hide the radial menu and associated buttons
    hide_radial_menu_and_buttons();

    // Set the keyboard context
    keyboard_context = "sound_settings";

    // Create the circular keyboard
    lv_obj_t * scr = lv_scr_act();




/* // 2) Create the keyboard on the screen
    lv_obj_t * test_keyboard = mc_circular_keyboard_create(scr, 180); 
  // e.g. radius=100
    if (!test_keyboard) {
        printf("Error: Circular keyboard creation failed.\n");
    } else {
        printf("Circular keyboard created successfully.\n");

        // Set keyboard properties
        mc_circular_keyboard_set_band_style(test_keyboard, lv_color_hex(0x0078D7), 30); // Set band color and thickness
        mc_circular_keyboard_set_style(test_keyboard, lv_color_hex(0xFFFFFF), lv_color_hex(0x000000), false); // Set key styles

        // Position the keyboard in the center
      //  mc_circular_keyboard_set_position(test_keyboard, 180, 180);

        // Set the "on close" callback
        mc_circular_keyboard_set_on_close(test_keyboard, []() {
            handle_keyboard_close(false); // Pass `false` for cancel
        });

        // Set the "OK button" callback
        mc_circular_keyboard_set_on_ok(test_keyboard, []() {
            handle_keyboard_close(true); // Pass `true` for OK
        });
    }
 */
    // Add sound settings controls here
}


// Wi-Fi Enable Function
void wifi_enable() {
    WiFi.mode(WIFI_STA);
    WiFi.setSleep(false);
    WiFi.disconnect(); // Ensure we're starting fresh
}

// Wi-Fi Disable Function
void wifi_disable() {
    WiFi.disconnect(true);
    WiFi.scanDelete();
    WiFi.mode(WIFI_OFF);
}
    // Define the close callback function
    void close_keyboard_callback(lv_event_t *e) {
        lv_obj_t *kb = (lv_obj_t *) lv_event_get_target(e);

        // Retrieve the user data stored in the keyboard
       // lv_obj_t **ui_elements = (lv_obj_t **)lv_obj_get_user_data(kb);
       // lv_obj_t *password_box = ui_elements[0];
       // lv_obj_t *save_btn = ui_elements[1];
       // lv_obj_t *connect_btn = ui_elements[2];

        // Clean up UI elements
        //lv_obj_del(password_box);
        //lv_obj_del(save_btn);
        //lv_obj_del(connect_btn);
        lv_obj_del(kb);

        // Optionally show other UI elements or reset state
      //  lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);

       // free(ui_elements); // Free the allocated memory
    }

void save_btn_cb(lv_event_t *e) {
    lv_obj_t *password_box = (lv_obj_t *)lv_event_get_user_data(e);
    if (!password_box) return; // Ensure password_box is valid

    const char *password = lv_textarea_get_text(password_box);
    Serial.printf("Saving network with password: %s\n", password);

    // Cleanup
    lv_obj_t *circular_keyboard = (lv_obj_t *)lv_obj_get_user_data(password_box);
    if (circular_keyboard) lv_obj_del(circular_keyboard);
    lv_obj_del(password_box);
    lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
}

void connect_btn_cb(lv_event_t *e) {
    lv_obj_t *password_box = (lv_obj_t *)lv_event_get_user_data(e);
    if (!password_box) return; // Ensure password_box is valid

    const char *password = lv_textarea_get_text(password_box);
    Serial.printf("Connecting to network with password: %s\n", password);

    // Cleanup
    lv_obj_t *circular_keyboard = (lv_obj_t *)lv_obj_get_user_data(password_box);
    if (circular_keyboard) lv_obj_del(circular_keyboard);
    lv_obj_del(password_box);
    lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
}

void cancel_btn_cb(lv_event_t *e) {
    lv_obj_t *password_box = (lv_obj_t *)lv_event_get_user_data(e);
    if (!password_box) return; // Ensure password_box is valid

    // Cleanup
    lv_obj_t *circular_keyboard = (lv_obj_t *)lv_obj_get_user_data(password_box);
    if (circular_keyboard) lv_obj_del(circular_keyboard);
    lv_obj_del(password_box);
    lv_obj_clear_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
}

// WiFi network selection callback
void wifi_network_selected_cb(lv_event_t * e)
{
    // 1) Get the SSID from event user data
    const char * selected_ssid = (const char *)lv_event_get_user_data(e);
    if (!selected_ssid) {
        Serial.println("Error: No SSID provided.");
        return;
    }
    Serial.printf("Selected SSID: %s\n", selected_ssid);

    // 2) Hide your radial menu and associated buttons (custom function in your code)
    hide_radial_menu_and_buttons();

    // 3) Create the password text area
    lv_obj_t * password_box = lv_textarea_create(content_area);
    if (!password_box) {
        Serial.println("Error: Could not create password text area.");
        show_radial_menu_and_buttons(); // re-show if error
        return;
    }
    lv_textarea_set_one_line(password_box, true);
    lv_textarea_set_password_mode(password_box, true);  // mask typed chars
    lv_textarea_set_placeholder_text(password_box, "Enter password...");
    lv_obj_align(password_box, LV_ALIGN_CENTER, 0, -50);

   /*  // 4) Create the circular keyboard
    lv_obj_t * ckb = mc_circular_keyboard_create(lv_scr_act(), 180); 
    if (!ckb) {
        Serial.println("Error: Failed to create circular keyboard.");
        lv_obj_del(password_box);
        show_radial_menu_and_buttons();
        return;
    }
    mc_circular_keyboard_set_band_style(ckb, lv_color_hex(0x0078D7), 30); // Set band color and thickness
        mc_circular_keyboard_set_style(ckb, lv_color_hex(0xFFFFFF), lv_color_hex(0x000000), false); // Set key styles
    // 5) Attach the text area to the keyboard
    mc_circular_keyboard_set_textarea(ckb, password_box);

    // 6) The ring’s Close [X] => remove keyboard + password box => user cancels
    //    Then re-show the radial menu
  
     mc_circular_keyboard_set_on_close(ckb, []() {
            handle_keyboard_close(false); // Pass `false` for cancel
        });
    // 7) The ring’s OK => just remove keyboard, leaving the password box
    //    Then re-show the radial menu so user can press a “Save” or “Connect” button
  

        // Set the "OK button" callback
        mc_circular_keyboard_set_on_ok(ckb, []() {
            handle_keyboard_close(true); // Pass `true` for OK
        }); */

    // 8) Optionally, create “Save” or “Connect” buttons
    //    that read the password text area’s content:
    lv_obj_t * save_btn = lv_btn_create(content_area);
    if(save_btn) {
        lv_obj_set_size(save_btn, 80, 40);
        lv_obj_align(save_btn, LV_ALIGN_CENTER, -50, 80);
        lv_obj_t * save_label = lv_label_create(save_btn);
        lv_label_set_text(save_label, "Save");

        // Provide user data so the callback can find the text area
        lv_obj_add_event_cb(save_btn, [](lv_event_t * ev) {
            lv_obj_t * btn = (lv_obj_t *) lv_event_get_target(ev);
            lv_obj_t * pbox = (lv_obj_t *)lv_event_get_user_data(ev);
            if(!pbox) return;

            const char * pwd = lv_textarea_get_text(pbox);
            Serial.printf("[SaveBtn] SSID password is: %s\n", pwd);

            // do your saving logic, e.g. store password, or connect
            // Then remove text area if done
            lv_obj_del(pbox);
            // remove the button
            lv_obj_del(btn);

            // re-show radial menu
            show_radial_menu_and_buttons();
        }, LV_EVENT_CLICKED, password_box);
    }



    // Create a connect button to connect directly
    lv_obj_t *connect_btn = lv_btn_create(content_area);
    if (connect_btn) {
        lv_obj_set_size(connect_btn, 80, 40);
        lv_obj_align(connect_btn, LV_ALIGN_CENTER, 50, 100);
        lv_obj_t *connect_label = lv_label_create(connect_btn);
        lv_label_set_text(connect_label, "Connect");
        lv_obj_add_event_cb(connect_btn, connect_btn_cb, LV_EVENT_CLICKED, password_box);
    }

}




// Saved network selection callback
void saved_network_selected_cb(lv_event_t *e) {
    const char *selected_ssid = (const char *)lv_event_get_user_data(e);
    Serial.printf("Selected saved SSID: %s\n", selected_ssid);

    // Create an edit button to update password
    lv_obj_t *edit_btn = lv_btn_create(content_area);
    lv_obj_t *label = lv_label_create(edit_btn);
    lv_label_set_text(label, "Edit");
    lv_obj_align(edit_btn, LV_ALIGN_CENTER, -50, 100);
    lv_obj_add_event_cb(edit_btn, edit_saved_network_event_cb, LV_EVENT_CLICKED, (void *)selected_ssid);

    // Create a remove button
    lv_obj_t *remove_btn = lv_btn_create(content_area);
    lv_obj_t *remove_label = lv_label_create(remove_btn);
    lv_label_set_text(remove_label, "Remove");
    lv_obj_align(remove_btn, LV_ALIGN_CENTER, 50, 100);
    lv_obj_add_event_cb(remove_btn, remove_saved_network_event_cb, LV_EVENT_CLICKED, (void *)selected_ssid);
}

// Save new WiFi network event callback
void save_wifi_network_event_cb(lv_event_t *e) {
    lv_obj_t *password_box = (lv_obj_t *)lv_event_get_user_data(e);
    const char *ssid = WiFi.SSID(WiFi.scanComplete() - 1).c_str(); // Get the last scanned SSID
    const char *password = lv_textarea_get_text(password_box);

    WiFiNetwork newNetwork;
    newNetwork.ssid = String(ssid);
    newNetwork.password = String(password);

    currentSettings.known_wifi_networks.push_back(newNetwork);
    saveSettingsDataToFile("/settings.json", currentSettings);

    Serial.printf("Saved SSID: %s\n", ssid);
    scan_and_display_wifi_networks();
}

// Edit saved network password event callback
void edit_saved_network_event_cb(lv_event_t *e) {
    const char *selected_ssid = (const char *)lv_event_get_user_data(e);

    // Create a text area to enter new password
    lv_obj_t *password_box = lv_textarea_create(content_area);
    lv_textarea_set_placeholder_text(password_box, "Enter new password...");
    lv_obj_align(password_box, LV_ALIGN_CENTER, 0, 50);
        // Create a keyboard to input the password
    password_kb = lv_keyboard_create(lv_scr_act());
    lv_obj_set_size(password_kb, 320, 240);
    lv_keyboard_set_textarea(password_kb, password_box);
    lv_obj_add_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
    // Set up the event callback for the keyboard to detect when "OK" is pressed
    lv_obj_add_event_cb(password_kb, [](lv_event_t *e) {
        lv_obj_t *keyboard = (lv_obj_t *)lv_event_get_target(e);
        lv_keyboard_mode_t mode = lv_keyboard_get_mode(keyboard);

        // If the OK button is pressed, delete the keyboard and text area
        if (lv_event_get_code(e) == LV_EVENT_READY) {
            lv_obj_remove_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
            lv_obj_del(keyboard);  // Delete the keyboard
            lv_obj_del(lv_keyboard_get_textarea(keyboard)); // Delete the text area
        }
    }, LV_EVENT_ALL, NULL);

    // Create a save button to update password
    lv_obj_t *save_btn = lv_btn_create(content_area);
    lv_obj_t *label = lv_label_create(save_btn);
    lv_label_set_text(label, "Save");
    lv_obj_align(save_btn, LV_ALIGN_CENTER, 0, 100);
    lv_obj_add_event_cb(save_btn, save_updated_password_event_cb, LV_EVENT_CLICKED, (void *)selected_ssid);
}

void save_updated_password_event_cb(lv_event_t * e) {
    // Get the text from the password box
    lv_obj_t * password_box = (lv_obj_t *)lv_event_get_target(e);
    String new_password = lv_textarea_get_text(password_box);
     lv_obj_remove_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
    // Get the selected SSID from user data
    const char * selected_ssid = (const char *)lv_event_get_user_data(e);

    // Find the network in the list of known Wi-Fi networks and update the password
    for (auto& network : currentSettings.known_wifi_networks) {
        if (network.ssid == selected_ssid) {
            network.password = new_password;
            Serial.printf("Updated password for SSID: %s\n", selected_ssid);
            break;
        }
    }

    // Save updated settings to the file
    saveSettingsDataToFile("/settings.json", currentSettings);

    // Optionally, provide feedback to the user
    lv_obj_t * msgbox = lv_msgbox_create(NULL);
    lv_obj_center(msgbox);
    lv_msgbox_add_title(msgbox, "Info");
    lv_msgbox_add_text(msgbox, "Password Updated");
    lv_msgbox_add_close_button(msgbox);
}

// Remove saved WiFi network event callback
void remove_saved_network_event_cb(lv_event_t *e) {
    const char *selected_ssid = (const char *)lv_event_get_user_data(e);
    Serial.printf("Removing SSID: %s\n", selected_ssid);

    auto &wifi_list = currentSettings.known_wifi_networks;
    wifi_list.erase(
        std::remove_if(wifi_list.begin(), wifi_list.end(),
                       [selected_ssid](const WiFiNetwork &network) {
                           return network.ssid == String(selected_ssid);
                       }),
        wifi_list.end());

    saveSettingsDataToFile("/settings.json", currentSettings);
    scan_and_display_wifi_networks();
}

void connect_wifi_network_event_cb(lv_event_t * e) {
    lv_obj_t * password_box = (lv_obj_t *)lv_event_get_user_data(e);
    String ssid = WiFi.SSID(WiFi.scanComplete() - 1); // Assuming the last scanned SSID is the one to connect to
    String password = lv_textarea_get_text(password_box);
     lv_obj_remove_flag(ui_SettingsRadialMenu, LV_OBJ_FLAG_HIDDEN);
    // Attempt to connect to the network
    Serial.printf("Attempting to connect to SSID: %s with password: %s\n", ssid.c_str(), password.c_str());
    WiFi.begin(ssid.c_str(), password.c_str());

    // Add additional connection status handling if needed
}


// Display WiFi networks (saved and scanned)
void scan_and_display_wifi_networks() {
    if (wifi_list == nullptr) {
        Serial.println("Error in scan & display networks: Wi-Fi list is not initialized.");
       // return;
    }
    wifi_enable();
    lv_obj_clean(wifi_list); // Clear previous content
    lv_list_add_text(wifi_list, "Networks Discovered");
    int networkCount = WiFi.scanNetworks();
    if (networkCount == 0) {
        lv_obj_t *list_btn = lv_list_add_btn(wifi_list, NULL, "No networks found");
        lv_obj_add_state(list_btn, LV_STATE_DISABLED);
    } else {
        std::vector<String> savedSSIDs;

        // Display scanned networks and identify saved networks
        for (int i = 0; i < networkCount; ++i) {
            const char *ssid = WiFi.SSID(i).c_str();
            bool isSaved = false;

            for (const auto &savedNetwork : currentSettings.known_wifi_networks) {
                if (savedNetwork.ssid == ssid) {
                    isSaved = true;
                    savedSSIDs.push_back(savedNetwork.ssid);
                    break;
                }
            }

            // Create a list item for each network
            lv_obj_t *list_btn = lv_list_add_button(wifi_list, NULL, ssid);
            lv_obj_add_event_cb(list_btn, wifi_network_selected_cb, LV_EVENT_CLICKED, (void *)ssid);

            // If the network is saved, mark it with a different color
            if (isSaved) {
                lv_obj_set_style_text_color(list_btn, lv_color_hex(0x41C7FF), 0); // Set a specific color
            }
        }

        // Display saved networks that weren't found in the current scan
        for (const auto &savedNetwork : currentSettings.known_wifi_networks) {
            if (std::find(savedSSIDs.begin(), savedSSIDs.end(), savedNetwork.ssid) == savedSSIDs.end()) {
                lv_obj_t *list_btn = lv_list_add_btn(wifi_list, NULL, savedNetwork.ssid.c_str());
                lv_obj_add_event_cb(list_btn, saved_network_selected_cb, LV_EVENT_CLICKED, (void *)savedNetwork.ssid.c_str());
                lv_obj_set_style_text_color(list_btn, lv_color_hex(0xAAAAAA), 0); // Greyed out to indicate it's not found
            }
        }
    }

    WiFi.scanDelete();
}