// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.1
// LVGL version: 8.3.11
// Project name: SmartWatch

#include "ui.h"
#include <Arduino.h>
// ui_clockscreen.c
#include "ui_ClockScreen.h"
#include "clock.h" // Include clock.h to access clock data
//#include "audio_bridge.h"
#include "AlarmManager.h"   // or whatever you named it
#include <math.h>

#define ALARM_RED lv_color_hex(0x8B1E1E)   // dark, classy red


// Declare UI elements
//lv_obj_t * ui_ClockScreen;
lv_obj_t * clock_scale;
//lv_obj_t * hour_hand_img;
//lv_obj_t * minute_hand_img;
lv_obj_t * second_hand_line;
lv_obj_t * alarm_hour_hand_img;
lv_obj_t * alarm_minute_hand_img;
lv_obj_t * alarm_bell_img;


static uint16_t alarm_edit_minutes_backup = 0;
static bool alarm_edit_mode = false;
static uint16_t alarm_edit_minutes = 7 * 60; // default 07:00 until loaded
static bool alarm_bell_longpress_fired = false;


static void alarm_bell_event_cb(lv_event_t * e);
static void alarm_enter_edit_mode(void);
static void alarm_commit_edit_mode(void);
static void alarm_update_ghost_needles(void);
static void alarm_drag_event_cb(lv_event_t * e);
static void alarm_hour_tap_cb(lv_event_t * e);
static void alarm_min_tap_cb(lv_event_t * e);
static void alarm_adjust_minutes(int delta);


void ui_ClockScreen_screen_init(void) {
    // Create the clock screen
    //printf("Creating clock Screen\n");
    ui_ClockScreen = lv_obj_create(NULL);
    lv_obj_clear_flag(ui_ClockScreen, LV_OBJ_FLAG_SCROLLABLE);

    // Set background image
    //lv_obj_set_style_bg_img_src(ui_ClockScreen, &watch360, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_size(ui_ClockScreen, 466, 466);
    lv_obj_set_align(ui_ClockScreen, LV_ALIGN_CENTER);

    // Main Arc Menu

     ui_MainArcClockMenu = lv_arc_create(ui_ClockScreen);
    lv_obj_set_width(ui_MainArcClockMenu, 250); // Adjusted for 360x360
    lv_obj_set_height(ui_MainArcClockMenu, 250);
    lv_obj_set_align(ui_MainArcClockMenu, LV_ALIGN_CENTER);
    lv_arc_set_range(ui_MainArcClockMenu, 0, 500);
    lv_arc_set_value(ui_MainArcClockMenu, 200);
    lv_obj_set_style_arc_color(ui_MainArcClockMenu, lv_color_hex(0xDDDDDD), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_opa(ui_MainArcClockMenu, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_width(ui_MainArcClockMenu, 8, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_rounded(ui_MainArcClockMenu, false, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_set_style_arc_color(ui_MainArcClockMenu, lv_color_hex(0x000000), LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_opa(ui_MainArcClockMenu, 255, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_width(ui_MainArcClockMenu, 5, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_rounded(ui_MainArcClockMenu, false, LV_PART_INDICATOR | LV_STATE_DEFAULT);

    lv_obj_set_style_bg_color(ui_MainArcClockMenu, lv_color_hex(0xFFFFFF), LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_MainArcClockMenu, 0, LV_PART_KNOB | LV_STATE_DEFAULT);

    lv_obj_add_event_cb(ui_MainArcClockMenu, ui_event_MainArcClockMenu, LV_EVENT_ALL, NULL);

    // Create the scale (clock face)
    clock_scale = lv_scale_create(ui_ClockScreen);
    lv_obj_clear_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_set_size(clock_scale, 412, 412);
    lv_obj_center(clock_scale);
    lv_scale_set_mode(clock_scale, LV_SCALE_MODE_ROUND_INNER);
    //lv_obj_set_style_bg_opa(clock_scale, 255, 0);
    lv_obj_set_style_bg_img_src(clock_scale, &watch360, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(clock_scale, LV_RADIUS_CIRCLE, 0);

    // --- tick & label setup for 5-second intervals ---
    lv_scale_set_label_show(clock_scale, true);
    lv_scale_set_total_tick_count(clock_scale, 61);   // 0–60 inclusive
    lv_scale_set_major_tick_every(clock_scale, 5);    // every 5 = major tick
    lv_scale_set_range(clock_scale, 0, 60);
    lv_scale_set_angle_range(clock_scale, 360);
    lv_scale_set_rotation(clock_scale, 270);          // 0/60 at 12 o’clock

    // Custom text labels: top is 60, skip duplicate at 60
    static const char *  five_sec_labels[] = {
        "60", "5", "10", "15", "20", "25", "30",
        "35", "40", "45", "50", "55", "", NULL
    };
    lv_scale_set_text_src(clock_scale, five_sec_labels);

    // -------- Style section --------

    // --- Minor ticks (1-second marks) ---
    lv_obj_set_style_line_width(clock_scale, 1, LV_PART_ITEMS);      // thin
    lv_obj_set_style_length(clock_scale, 6, LV_PART_ITEMS);          // short
    lv_obj_set_style_line_color(clock_scale, lv_color_hex(0x303030), LV_PART_ITEMS);
    lv_obj_set_style_line_opa(clock_scale, LV_OPA_100, LV_PART_ITEMS);

    // --- Major ticks (5-second marks) ---
    lv_obj_set_style_line_width(clock_scale, 3, LV_PART_INDICATOR);  // thicker
    lv_obj_set_style_length(clock_scale, 12, LV_PART_INDICATOR);     // longer
    lv_obj_set_style_line_color(clock_scale, lv_color_hex(0x000000), LV_PART_INDICATOR);
    lv_obj_set_style_line_opa(clock_scale, LV_OPA_COVER, LV_PART_INDICATOR);

    // --- Label text (shares LV_PART_INDICATOR) ---
    lv_obj_set_style_text_color(clock_scale, lv_color_hex(0x4169E1), LV_PART_INDICATOR); // Royal Blue
    lv_obj_set_style_text_opa(clock_scale, LV_OPA_COVER, LV_PART_INDICATOR);

    // Rotate labels to match tick angle (no KEEP_UPRIGHT -> bottom labels are upside-down)
    lv_obj_set_style_transform_rotation(clock_scale, LV_SCALE_LABEL_ROTATE_MATCH_TICKS + 900, LV_PART_INDICATOR);
    // Apply an extra rotation offset of -90° (units = 0.1°)
  //  lv_obj_set_style_transform_angle(clock_scale, 0, LV_PART_INDICATOR);
    // If that flips the wrong way on your build, use +900 instead.


    // Fine-tune spacing of labels
    lv_obj_set_style_pad_all(clock_scale, 4, LV_PART_INDICATOR);

    lv_scale_set_range(clock_scale, 0, 60);
    lv_scale_set_angle_range(clock_scale, 360);
    lv_scale_set_rotation(clock_scale, 270); // Start at the top
    
  
    
    // Create hour hand image
    hour_hand_img = lv_img_create(clock_scale);
    lv_img_set_src(hour_hand_img, &hour_hand);
    //lv_obj_center(hour_hand_img);
    lv_img_set_pivot(hour_hand_img, 0, 6);
    lv_obj_align(hour_hand_img, LV_ALIGN_CENTER, 41, 0);
    lv_img_set_angle(hour_hand_img, 0);

    // Create minute hand image
    minute_hand_img = lv_img_create(clock_scale);
    lv_img_set_src(minute_hand_img, &minute_hand);
    //lv_obj_center(minute_hand_img);
    lv_img_set_pivot(minute_hand_img, 0, 5);
    lv_obj_align(minute_hand_img, LV_ALIGN_CENTER, 54, 0);
    lv_img_set_angle(minute_hand_img, 0);
  

     // --- Alarm ghost hands (hidden by default) ---

    alarm_hour_hand_img = lv_img_create(clock_scale);
    lv_img_set_src(alarm_hour_hand_img, &hour_hand);
    lv_img_set_pivot(alarm_hour_hand_img, 0, 6);
    lv_obj_align(alarm_hour_hand_img, LV_ALIGN_CENTER, 41, 0);
    lv_obj_set_style_img_opa(alarm_hour_hand_img, LV_OPA_40, LV_PART_MAIN);
    lv_obj_add_flag(alarm_hour_hand_img, LV_OBJ_FLAG_HIDDEN);
        // Allow tapping the ghost hands
    lv_obj_add_flag(alarm_hour_hand_img, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(alarm_hour_hand_img, alarm_hour_tap_cb, LV_EVENT_CLICKED, nullptr);




    alarm_minute_hand_img = lv_img_create(clock_scale);
    lv_img_set_src(alarm_minute_hand_img, &minute_hand);
    lv_img_set_pivot(alarm_minute_hand_img, 0, 5);
    lv_obj_align(alarm_minute_hand_img, LV_ALIGN_CENTER, 54, 0);
    lv_obj_set_style_img_opa(alarm_minute_hand_img, LV_OPA_40, LV_PART_MAIN);
    lv_obj_add_flag(alarm_minute_hand_img, LV_OBJ_FLAG_HIDDEN);
    // Drag on the dial to set minutes by angle
    lv_obj_add_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);          // so it receives pointer events
    //lv_obj_add_event_cb(clock_scale, alarm_drag_event_cb, LV_EVENT_PRESSING, nullptr);

    // --- Alarm bell icon "complication" ---
    // NOTE: replace &ui_img_bell_png with your actual bell image symbol.
 // Hit target (bigger than the icon)
    lv_obj_t * alarm_bell_hit = lv_obj_create(clock_scale);
    lv_obj_move_foreground(alarm_bell_hit);
    lv_obj_set_size(alarm_bell_hit, 56, 56);                 // tweak: 44–64 is typical
    lv_obj_align(alarm_bell_hit, LV_ALIGN_CENTER, 0, -90);
    lv_obj_set_style_bg_opa(alarm_bell_hit, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_opa(alarm_bell_hit, LV_OPA_TRANSP, 0);
    lv_obj_clear_flag(alarm_bell_hit, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_flag(alarm_bell_hit, LV_OBJ_FLAG_CLICKABLE);

    // The bell image as a child (visual only)
    alarm_bell_img = lv_img_create(alarm_bell_hit);
    lv_img_set_src(alarm_bell_img, "A:/lvgl/img/bell_icon.png");
    //lv_obj_set_style_bg_opa(alarm_bell_hit, LV_OPA_TRANSP, 0);
    lv_obj_center(alarm_bell_img);
    lv_obj_set_style_transform_zoom(alarm_bell_img, 150, LV_PART_MAIN); // 75%

    // Click handler on the BIG hit target, not the image
    lv_obj_add_event_cb(alarm_bell_hit, alarm_bell_event_cb, LV_EVENT_CLICKED, nullptr);
    lv_obj_add_event_cb(alarm_bell_hit, alarm_bell_longpress_cb, LV_EVENT_LONG_PRESSED, nullptr);


   // lv_obj_align(alarm_bell_img, LV_ALIGN_CENTER, 0, -90); // put near 12 o'clock; tweak
    lv_obj_add_flag(alarm_bell_img, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_clear_flag(alarm_bell_img, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_event_cb(alarm_bell_img, alarm_bell_event_cb, LV_EVENT_CLICKED, NULL);


    lv_obj_add_flag(alarm_minute_hand_img, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(alarm_minute_hand_img, alarm_min_tap_cb, LV_EVENT_CLICKED, nullptr);

    lv_obj_add_event_cb(alarm_hour_hand_img, alarm_stop_bubble_cb, LV_EVENT_PRESSED, nullptr);
    lv_obj_add_event_cb(alarm_hour_hand_img, alarm_stop_bubble_cb, LV_EVENT_PRESSING, nullptr);

    lv_obj_add_event_cb(alarm_minute_hand_img, alarm_stop_bubble_cb, LV_EVENT_PRESSED, nullptr);
    lv_obj_add_event_cb(alarm_minute_hand_img, alarm_stop_bubble_cb, LV_EVENT_PRESSING, nullptr);





  // Create second hand line
    second_hand_line = lv_line_create(clock_scale);
    // Define points for the second hand line
    static lv_point_precise_t second_hand_points[] = {{0, 0}, {0, 90}}; // Adjust length as needed
    lv_line_set_points(second_hand_line, second_hand_points, 2);
    lv_obj_center(second_hand_line);
    lv_obj_set_style_line_width(second_hand_line, 2, 0);
    lv_obj_set_style_line_color(second_hand_line, lv_palette_main(LV_PALETTE_RED), 0);
    lv_obj_set_style_line_rounded(second_hand_line, true, 0);
    lv_obj_set_style_transform_pivot_x(second_hand_line, 0, 0);
    lv_obj_set_style_transform_pivot_y(second_hand_line, 0, 0); 
   
   // Create a circle dot to cover the middle.

    lv_obj_t * circle_dot = lv_obj_create(clock_scale);
    lv_obj_set_size(circle_dot, 10, 10);
    lv_obj_align(circle_dot, LV_ALIGN_CENTER, 0, 0);
    lv_obj_set_style_radius(circle_dot, LV_RADIUS_CIRCLE, 0);
    lv_obj_set_style_bg_color(circle_dot, lv_color_hex(0x000000), 0);
    lv_obj_set_style_bg_opa(circle_dot, 255, 0);
    lv_obj_set_style_border_opa(circle_dot, 255, 0);
    lv_obj_set_style_border_color(circle_dot, lv_palette_main(LV_PALETTE_BLUE_GREY), 0);

 
    lv_obj_clear_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_clear_state(ui_MainArcClockMenu, LV_STATE_DISABLED);

    alarm_update_bell_style();

    // Call update to set initial positions
    update_clock_screen();
}

void update_clock_screen(void) {
    if (lv_scr_act() != ui_ClockScreen) {
        // Clock screen is not active; no need to update
        return;
    }

        static int8_t prev_second = -1;          // keeps its value between calls
    if (second_value != prev_second) {       // <- second_value comes from your RTC
     //   playSound("/lvgl/snd/tick.mp3");

        prev_second = second_value;
    }

   // printf("updating clock screen \n");
    // Calculate angles
    int32_t hour_angle = ((hour_value % 12) * 30 * 10) + (minute_value * 5); // In LVGL angle units (0.1 degrees)
    int32_t minute_angle = minute_value * 6 * 10; // 6 degrees per minute
    int32_t second_angle = second_value * 6 * 10; // 6 degrees per second
    //printf("Setting hour hand value %d .\n", hour_value);

    // Map the hour to the 0-60 scale
float hour_base_value = hour_value * 5.0f; // Each hour corresponds to 5 units

// Calculate the minute adjustment
float minute_adjustment = (minute_value / 60.0f) * 5.0f; // Adjusts the hour hand based on minutes

// Calculate the final hour value on the scale
float hour_scale_value = hour_base_value + minute_adjustment;

    lv_scale_set_image_needle_value(clock_scale, hour_hand_img, hour_scale_value);
    lv_scale_set_image_needle_value(clock_scale, minute_hand_img, minute_value);
    lv_scale_set_line_needle_value(clock_scale, second_hand_line, 140, second_value);

    // Set angles to the images
    //lv_img_set_angle(hour_hand_img, hour_angle);
    //lv_img_set_angle(minute_hand_img, minute_angle);
   // lv_obj_set_style_transform_angle(second_hand_line, second_angle, 0);

    // Optionally, refresh the screen
    // lv_obj_invalidate(ui_ClockScreen);
}

static void alarm_bell_event_cb(lv_event_t * e)
{
    //LV_UNUSED(e);
     // If a long-press just happened, swallow the following click
    if (alarm_bell_longpress_fired) {
        alarm_bell_longpress_fired = false;
        lv_event_stop_bubbling(e);
        lv_event_stop_processing(e);
        return;
    }

    if (!alarm_edit_mode) {
        alarm_enter_edit_mode();
    } else {
        alarm_commit_edit_mode();
    }
}

static void alarm_enter_edit_mode(void)
{

     // Disable arc interaction while setting alarm
    lv_obj_add_state(ui_MainArcClockMenu, LV_STATE_DISABLED);

    // Pull current alarm time from the manager (or default)
    uint8_t h = 7, m = 0;
    if (AlarmManager::instance().isEnabled()) {
        AlarmManager::instance().get(h, m);
    }

    alarm_edit_minutes = (uint16_t)h * 60u + (uint16_t)m;

     alarm_edit_minutes_backup = alarm_edit_minutes; 

    lv_obj_add_event_cb(clock_scale, alarm_drag_event_cb, LV_EVENT_PRESSING, nullptr);
    lv_obj_add_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(clock_scale, alarm_drag_event_cb, LV_EVENT_PRESSED, nullptr);
    lv_obj_add_event_cb(clock_scale, alarm_drag_event_cb, LV_EVENT_RELEASED, nullptr);
    lv_obj_add_event_cb(clock_scale, alarm_drag_event_cb, LV_EVENT_PRESS_LOST, nullptr);


    lv_obj_clear_flag(alarm_hour_hand_img, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(alarm_minute_hand_img, LV_OBJ_FLAG_HIDDEN);

    alarm_update_ghost_needles();
    alarm_edit_mode = true;
    alarm_update_bell_style();
}

static void alarm_commit_edit_mode(void)
{
    uint8_t h = (uint8_t)(alarm_edit_minutes / 60u);
    uint8_t m = (uint8_t)(alarm_edit_minutes % 60u);

    AlarmManager::instance().set(h, m);

    lv_obj_remove_event_cb(clock_scale, alarm_drag_event_cb);
    lv_obj_clear_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);      // CRITICAL: give touches back to arc/menu
    lv_obj_add_flag(alarm_hour_hand_img, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(alarm_minute_hand_img, LV_OBJ_FLAG_HIDDEN);

    alarm_edit_mode = false;

    // Re-enable arc interaction
    lv_obj_clear_state(ui_MainArcClockMenu, LV_STATE_DISABLED);
    alarm_update_bell_style();
}

static void alarm_update_ghost_needles(void)
{
    // Convert alarm_edit_minutes into the same scale logic you used for hour hand.
    uint16_t min = alarm_edit_minutes % 60u;
    uint16_t hour24 = alarm_edit_minutes / 60u;
    uint16_t hour12 = hour24 % 12u;

    float hour_base_value = hour12 * 5.0f;
    float minute_adjustment = (min / 60.0f) * 5.0f;
    float hour_scale_value = hour_base_value + minute_adjustment;

    lv_scale_set_image_needle_value(clock_scale, alarm_hour_hand_img, hour_scale_value);
    lv_scale_set_image_needle_value(clock_scale, alarm_minute_hand_img, (float)min);
}

static void alarm_adjust_minutes(int delta)
{
    if (!alarm_edit_mode) return;

    int v = (int)alarm_edit_minutes + delta;

    // wrap 0..1439
    v %= 1440;
    if (v < 0) v += 1440;

    alarm_edit_minutes = (uint16_t)v;
    alarm_update_ghost_needles();
}

static void alarm_hour_tap_cb(lv_event_t * e)
{
    LV_UNUSED(e);
    // +1 hour
    alarm_adjust_minutes(+60);
}

static void alarm_min_tap_cb(lv_event_t * e)
{
    LV_UNUSED(e);
    // +5 minutes
    alarm_adjust_minutes(+5);
}

static void alarm_drag_event_cb(lv_event_t * e)
{
    if (!alarm_edit_mode) return;

    const lv_event_code_t code = lv_event_get_code(e);

    static bool drag_active = false;
    static int last_min = 0;   // 0..55 step 5

    if (code == LV_EVENT_PRESSED) {
        drag_active = true;
        last_min = (int)(alarm_edit_minutes % 60u);
        last_min = (last_min / 5) * 5;
        return;
    }

    if (code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST) {
        drag_active = false;
        return;
    }

    if (code != LV_EVENT_PRESSING || !drag_active) return;

    // Get touch point
    lv_point_t p;
    lv_indev_t * indev = lv_indev_get_act();
    if (!indev) return;
    lv_indev_get_point(indev, &p);

    // Center of clock_scale in screen coords
    int32_t cx, cy;
    {
        int32_t x = lv_obj_get_x(clock_scale);
        int32_t y = lv_obj_get_y(clock_scale);
        int32_t w = lv_obj_get_width(clock_scale);
        int32_t h = lv_obj_get_height(clock_scale);
        cx = x + w / 2;
        cy = y + h / 2;
    }

    int32_t dx = p.x - cx;
    int32_t dy = p.y - cy;

    // Ignore touches near center
    if ((dx*dx + dy*dy) < 20*20) return;

    // Angle: 0 at 12 o'clock, clockwise positive
    float ang = atan2f((float)dy, (float)dx) * 180.0f / (float)M_PI;
    ang += 90.0f;
    if (ang < 0) ang += 360.0f;

    int new_min = (int)lroundf(ang / 6.0f) % 60;
    new_min = (new_min / 5) * 5;      // snap to 5
    if (new_min == 60) new_min = 0;

    // Detect wrap to advance/retreat hour
    int diff = new_min - last_min;

    // Example:
    // 55 -> 0 : diff = -55  (wrap forward)
    // 0  -> 55: diff = +55  (wrap backward)
    if (diff <= -30) {
        alarm_adjust_minutes(+60);
    } else if (diff >= +30) {
        alarm_adjust_minutes(-60);
    }

    // Now set minute component exactly (without changing hour again)
    uint16_t hour24 = alarm_edit_minutes / 60u;
    alarm_edit_minutes = hour24 * 60u + (uint16_t)new_min;

    alarm_update_ghost_needles();
    last_min = new_min;
}


static void alarm_stop_bubble_cb(lv_event_t * e)
{
    if (!alarm_edit_mode) return;
    lv_event_stop_bubbling(e);     // prevents clock_scale handler getting the drag
}

static void alarm_update_bell_style(void)
{
    if (alarm_edit_mode) {
        // Editing → black
        lv_obj_set_style_img_recolor(alarm_bell_img, lv_color_hex(0x000000), LV_PART_MAIN);
        lv_obj_set_style_img_recolor_opa(alarm_bell_img, LV_OPA_COVER, LV_PART_MAIN);
        return;
    }

    if (AlarmManager::instance().isEnabled()) {
        // Armed → dark red
        lv_obj_set_style_img_recolor(alarm_bell_img, lv_color_hex(0x8B1E1E), LV_PART_MAIN);
        lv_obj_set_style_img_recolor_opa(alarm_bell_img, LV_OPA_COVER, LV_PART_MAIN);
    } else {
        // Idle → light grey
        lv_obj_set_style_img_recolor(alarm_bell_img, lv_color_hex(0xB0B0B0), LV_PART_MAIN);
        lv_obj_set_style_img_recolor_opa(alarm_bell_img, LV_OPA_90, LV_PART_MAIN);
    }
}

static void alarm_bell_longpress_cb(lv_event_t * e)
{
   // LV_UNUSED(e);
    alarm_bell_longpress_fired = true;
     // Prevent other widgets (arc menu, etc.) reacting
    lv_event_stop_bubbling(e);

    // Optional: also stop further processing on this object
    lv_event_stop_processing(e);


    if (alarm_edit_mode) {
        // CANCEL EDIT: restore previous time, hide ghosts, re-enable menu
        alarm_edit_minutes = alarm_edit_minutes_backup;
        alarm_update_ghost_needles();

        lv_obj_add_flag(alarm_hour_hand_img, LV_OBJ_FLAG_HIDDEN);
        lv_obj_add_flag(alarm_minute_hand_img, LV_OBJ_FLAG_HIDDEN);

        alarm_edit_mode = false;

        // give control back to arc/menu
        lv_obj_clear_state(ui_MainArcClockMenu, LV_STATE_DISABLED);
        lv_obj_remove_event_cb(clock_scale, alarm_drag_event_cb);
        lv_obj_clear_flag(clock_scale, LV_OBJ_FLAG_CLICKABLE);

        alarm_update_bell_style();
        return;
    }

    // NOT editing: disable alarm (turn off)
    AlarmManager::instance().disable();
    alarm_update_bell_style();
}